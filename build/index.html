<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Event Tracker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 95%;
            width: 100%;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            padding: 30px;
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        .session-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .session-card {
            background: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .session-card:hover {
            border-color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .session-card h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 18px;
        }

        .session-card .session-meta {
            color: #666;
            font-size: 13px;
            margin-bottom: 5px;
        }

        .session-card .delete-session-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 5px 10px;
            font-size: 12px;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .session-card:hover .delete-session-btn {
            opacity: 1;
        }

        .session-card .delete-session-btn:hover {
            background: #c82333;
        }

        .new-session-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px dashed #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 150px;
            color: white;
            font-size: 48px;
        }

        .new-session-card:hover {
            border-color: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .back-btn {
            padding: 10px 20px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-bottom: 20px;
            transition: background 0.3s ease;
        }

        .back-btn:hover {
            background: #5a6268;
        }

        h1 {
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .available-events-panel {
            background: #f8f9fa;
            border: 2px solid #6c757d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .available-events-panel h2 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .event-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
        }

        .event-btn {
            padding: 20px;
            font-size: 16px;
            font-weight: 600;
            border: 3px solid transparent;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 8px;
            position: relative;
            min-height: 100px;
        }

        .event-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .event-btn:active {
            transform: translateY(0);
        }

        .event-btn.meeting { background: #3b82f6; }
        .event-btn.break { background: #10b981; }
        .event-btn.task { background: #f59e0b; }
        .event-btn.phone { background: #ef4444; }
        .event-btn.email { background: #8b5cf6; }
        .event-btn.other { background: #ec4899; }

        .event-btn.active {
            border-color: #fff;
            box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3), 0 6px 12px rgba(0, 0, 0, 0.2);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.3), 0 6px 12px rgba(0, 0, 0, 0.2);
            }
            50% {
                box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.5), 0 8px 16px rgba(0, 0, 0, 0.3);
            }
        }

        .event-btn-label {
            font-size: 16px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .event-btn-status {
            font-size: 12px;
            font-weight: 500;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .event-btn-duration {
            font-size: 14px;
            font-weight: 600;
            font-family: 'Courier New', monospace;
            background: rgba(0, 0, 0, 0.2);
            padding: 4px 12px;
            border-radius: 12px;
            min-width: 80px;
            text-align: center;
        }

        .event-btn-instances {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 11px;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 10px;
            min-width: 20px;
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .clear-btn {
            padding: 10px 20px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .clear-btn:hover {
            background: #b91c1c;
        }

        .csv-btn {
            padding: 10px 20px;
            background: #0891b2;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .csv-btn:hover {
            background: #0e7490;
        }

        .reset-btn {
            padding: 10px 20px;
            background: #f97316;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .reset-btn:hover {
            background: #ea580c;
        }

        .events-list {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .events-list h2 {
            color: #856404;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .event-item {
            background: white;
            padding: 12px 15px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .event-item.running {
            background: #e7f5ff;
        }

        .event-type {
            font-weight: 600;
            color: #333;
            flex: 1;
        }

        .event-time {
            color: #666;
            font-size: 13px;
            text-align: right;
        }

        .event-duration {
            color: #28a745;
            font-weight: 600;
            font-size: 13px;
            margin-left: 10px;
        }

        .empty-state {
            text-align: center;
            color: #999;
            padding: 40px 20px;
            font-style: italic;
        }

        .event-types-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-bottom: 15px;
        }

        .event-type-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px solid #e9ecef;
            flex-wrap: wrap;
        }

        .event-type-item input[type="text"] {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
        }

        .event-type-item input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        .event-type-item input[type="color"] {
            width: 60px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            background: white;
        }

        .event-type-item select {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            background: white;
            cursor: pointer;
            min-width: 150px;
        }

        .event-type-item select:focus {
            outline: none;
            border-color: #667eea;
        }

        .complementary-label {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        .event-type-item input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        .event-type-item input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: 4px;
        }

        .delete-event-btn {
            padding: 8px 12px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .delete-event-btn:hover {
            background: #b91c1c;
        }

        .add-event-btn {
            padding: 10px 20px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .add-event-btn:hover {
            background: #059669;
        }

        .save-settings-btn {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background 0.3s ease;
            width: 100%;
            margin-top: 10px;
        }

        .save-settings-btn:hover {
            background: #5568d3;
        }

        .settings-section h3 {
            color: #333;
            margin-bottom: 10px;
            margin-top: 20px;
            font-size: 16px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .settings-section h3:first-of-type {
            margin-top: 0;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 15px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }

        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }

        .timeline-btn {
            padding: 10px 20px;
            background: #7c3aed;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
        }

        .timeline-btn:hover {
            background: #6d28d9;
        }

        .timeline-section {
            background: #f9fafb;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }

        .timeline-section.show {
            display: block;
        }

        .timeline-section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .timeline-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
            align-items: center;
        }

        .timeline-controls label {
            color: #666;
            font-size: 14px;
            font-weight: 600;
        }

        .timeline-controls input,
        .timeline-controls select {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .download-timeline-btn {
            padding: 8px 16px;
            background: #059669;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: background 0.3s ease;
            margin-left: auto;
        }

        .download-timeline-btn:hover {
            background: #047857;
        }

        #timelineCanvas {
            width: 100%;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            background: white;
            cursor: crosshair;
        }

        .timeline-tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            pointer-events: none;
            z-index: 1000;
            display: none;
            white-space: nowrap;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .timeline-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 6px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
        }

        .legend-label {
            font-size: 14px;
            color: #333;
            font-weight: 500;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 20px;
            border-bottom: 2px solid #e5e7eb;
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-weight: 600;
            font-size: 15px;
            color: #666;
            transition: all 0.3s ease;
        }

        .tab:hover {
            color: #333;
            background: #f9fafb;
        }

        .tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .settings-section {
            background: #f9fafb;
            border-radius: 8px;
            padding: 20px;
        }

        .settings-section h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 20px;
        }

        .setting-item {
            background: white;
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        .setting-item h3 {
            color: #333;
            font-size: 16px;
            margin-bottom: 8px;
        }

        .setting-item p {
            color: #666;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .setting-item select {
            padding: 10px 15px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            width: 100%;
            max-width: 300px;
            cursor: pointer;
        }

        .setting-item select:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Landing Page View -->
        <div id="landingView" class="view active">
            <h1>üìä Event Tracker</h1>
            <p class="subtitle">Select a tracking session or create a new one</p>

            <h2 style="margin-bottom: 20px; color: #333;">Your Tracking Sessions</h2>
            <div class="session-list" id="sessionList">
                <!-- Sessions will be rendered here -->
            </div>

            <h2 style="margin-top: 40px; margin-bottom: 20px; color: #333;">‚öôÔ∏è Global Settings</h2>
            <div class="settings-panel">
                <div class="setting-section">
                    <h3>Event Types</h3>
                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">Define the types of events you want to track across all sessions</p>
                    <div class="event-types-list" id="globalEventTypesList"></div>
                    <button class="add-event-btn" onclick="addGlobalEventType()">‚ûï Add Event Type</button>
                </div>

                <div class="setting-section" style="margin-top: 30px;">
                    <h3>Timeline Time Scale</h3>
                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">Compress or expand the timeline visualization</p>
                    <select id="globalTimeScaleSetting" onchange="saveGlobalTimeScale()">
                        <option value="1">1:1 (Real-time - 1 second = 1 second)</option>
                        <option value="60">1:60 (1 minute = 1 second)</option>
                        <option value="120">1:120 (2 minutes = 1 second)</option>
                        <option value="300">1:300 (5 minutes = 1 second)</option>
                        <option value="600">1:600 (10 minutes = 1 second)</option>
                        <option value="1800">1:1800 (30 minutes = 1 second)</option>
                        <option value="3600">1:3600 (1 hour = 1 second)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Tracking View -->
        <div id="trackingView" class="view">
            <button class="back-btn" onclick="backToLanding()">‚Üê Back to Sessions</button>

            <h1 id="sessionTitle">Event Tracker</h1>
            <p class="subtitle">Start and stop events to track your activities</p>

            <div class="controls">
                <button class="csv-btn" onclick="exportCSV()">Export to CSV</button>
                <button class="reset-btn" onclick="resetEvents()">Reset Events</button>
            </div>

            <div class="tabs">
                <button class="tab active" onclick="switchTab('events')">Events</button>
                <button class="tab" onclick="switchTab('timeline')">Timeline</button>
            </div>

        <div id="eventsTab" class="tab-content active">
            <div class="available-events-panel">
                <h2>üìä Event Tracker - Click to Start/Stop</h2>
                <div class="event-buttons" id="eventButtons">
                </div>
            </div>

            <div class="events-list">
                <h2>üìú Event History</h2>
                <div id="eventsList"></div>
            </div>
        </div>

        <div id="timelineTab" class="tab-content">
            <div class="timeline-section show">
                <h2>Activity Timeline</h2>
                <div class="timeline-controls">
                    <label for="timelineDate">Date:</label>
                    <input type="date" id="timelineDate" onchange="saveTimelineSettings(); generateTimeline()">

                    <label for="timelineView">View:</label>
                    <select id="timelineView" onchange="saveTimelineSettings(); generateTimeline()">
                        <option value="day">Day View (24 hours)</option>
                        <option value="range">Date Range</option>
                    </select>

                    <input type="date" id="timelineEndDate" style="display: none;" onchange="saveTimelineSettings(); generateTimeline()">

                    <button class="download-timeline-btn" onclick="downloadTimeline()">Download Image</button>
                </div>
                <canvas id="timelineCanvas"></canvas>
                <div class="timeline-legend" id="timelineLegend"></div>
            </div>
        </div>

        </div>
        <!-- End of Tracking View -->
    </div>
    <!-- End of Container -->

    <div id="toast" class="toast"></div>
    <div class="timeline-tooltip" id="timelineTooltip"></div>

    <script>
        const SESSIONS_KEY = 'trackingSessions';
        const GLOBAL_SETTINGS_KEY = 'globalSettings';
        let currentSessionId = null;
        let updateInterval;

        const DEFAULT_EVENT_TYPES = [];

        function getSessions() {
            const data = localStorage.getItem(SESSIONS_KEY);
            return data ? JSON.parse(data) : [];
        }

        function saveSessions(sessions) {
            localStorage.setItem(SESSIONS_KEY, JSON.stringify(sessions));
        }

        function createSession(name) {
            const sessions = getSessions();
            const newSession = {
                id: 'session-' + Date.now(),
                name: name || 'Untitled Session',
                createdAt: new Date().toISOString(),
                lastModified: new Date().toISOString()
            };
            sessions.push(newSession);
            saveSessions(sessions);
            return newSession;
        }

        function deleteSession(sessionId) {
            const sessions = getSessions().filter(s => s.id !== sessionId);
            saveSessions(sessions);
            localStorage.removeItem(sessionId + '-events');
            localStorage.removeItem(sessionId + '-activeEvents');
        }

        function updateSessionTimestamp(sessionId) {
            const sessions = getSessions();
            const session = sessions.find(s => s.id === sessionId);
            if (session) {
                session.lastModified = new Date().toISOString();
                saveSessions(sessions);
            }
        }

        function getSessionStorageKey(key) {
            return currentSessionId ? `${currentSessionId}-${key}` : key;
        }

        function getGlobalSettings() {
            const data = localStorage.getItem(GLOBAL_SETTINGS_KEY);
            return data ? JSON.parse(data) : { timeScale: 1, eventTypes: [] };
        }

        function saveGlobalSettings(settings) {
            localStorage.setItem(GLOBAL_SETTINGS_KEY, JSON.stringify(settings));
        }

        function showLandingView() {
            document.getElementById('landingView').classList.add('active');
            document.getElementById('trackingView').classList.remove('active');
            currentSessionId = null;
            stopUpdateInterval();
            renderSessionList();
            renderGlobalEventTypes();
            loadGlobalSettings();
        }

        function showTrackingView(sessionId) {
            currentSessionId = sessionId;
            document.getElementById('landingView').classList.remove('active');
            document.getElementById('trackingView').classList.add('active');

            const sessions = getSessions();
            const session = sessions.find(s => s.id === sessionId);
            if (session) {
                document.getElementById('sessionTitle').textContent = session.name;
            }

            renderEventButtons();
            displayEvents();
            loadTimelineSettings();

            if (getActiveEvents().length > 0) {
                startUpdateInterval();
            }
        }

        function backToLanding() {
            if (confirm('Return to session list? Any active events will continue running.')) {
                showLandingView();
            }
        }

        function renderSessionList() {
            const sessions = getSessions();
            const container = document.getElementById('sessionList');

            const sessionCards = sessions.map(session => {
                const created = new Date(session.createdAt).toLocaleDateString();
                const modified = new Date(session.lastModified).toLocaleString();
                return `
                    <div class="session-card" onclick="openSession('${session.id}')">
                        <button class="delete-session-btn" onclick="event.stopPropagation(); deleteSessionConfirm('${session.id}')">Delete</button>
                        <h3>${session.name}</h3>
                        <div class="session-meta">Created: ${created}</div>
                        <div class="session-meta">Last modified: ${modified}</div>
                    </div>
                `;
            }).join('');

            const newSessionCard = `
                <div class="session-card new-session-card" onclick="createNewSession()">
                    <div>+</div>
                </div>
            `;

            container.innerHTML = newSessionCard + sessionCards;
        }

        function createNewSession() {
            const name = prompt('Enter session name:');
            if (name) {
                const session = createSession(name);
                openSession(session.id);
            }
        }

        function openSession(sessionId) {
            showTrackingView(sessionId);
        }

        function deleteSessionConfirm(sessionId) {
            const sessions = getSessions();
            const session = sessions.find(s => s.id === sessionId);
            if (session && confirm(`Delete session "${session.name}"? This cannot be undone.`)) {
                deleteSession(sessionId);
                renderSessionList();
                showToast('Session deleted');
            }
        }

        function renderGlobalEventTypes() {
            const eventTypes = getEventTypes();
            const container = document.getElementById('globalEventTypesList');

            if (eventTypes.length === 0) {
                container.innerHTML = '<div class="empty-state">No event types yet. Click "Add Event Type" below to get started.</div>';
                return;
            }

            container.innerHTML = eventTypes.map((eventType, index) => {
                const complementaryOptions = eventTypes
                    .filter((_, i) => i !== index)
                    .map(et => `<option value="${et.name}" ${eventType.complementary === et.name ? 'selected' : ''}>${et.name}</option>`)
                    .join('');

                return `
                    <div class="event-type-item">
                        <input type="text"
                               value="${eventType.name}"
                               placeholder="Event name"
                               data-index="${index}"
                               onchange="updateGlobalEventTypeName(${index}, this.value)">
                        <input type="color"
                               value="${eventType.color}"
                               data-index="${index}"
                               onchange="updateGlobalEventTypeColor(${index}, this.value)">
                        <div style="display: flex; flex-direction: column; gap: 4px;">
                            <label class="complementary-label">Complementary:</label>
                            <select onchange="updateGlobalEventTypeComplementary(${index}, this.value)">
                                <option value="">None</option>
                                ${complementaryOptions}
                            </select>
                        </div>
                        <button class="delete-event-btn" onclick="deleteGlobalEventType(${index})">üóëÔ∏è Delete</button>
                    </div>
                `;
            }).join('');
        }

        function addGlobalEventType() {
            const eventTypes = getEventTypes();
            eventTypes.push({ name: 'New Event', color: '#999999', complementary: null });
            saveEventTypesToStorage(eventTypes);
            renderGlobalEventTypes();
        }

        function updateGlobalEventTypeName(index, newName) {
            const eventTypes = getEventTypes();
            if (eventTypes[index]) {
                const oldName = eventTypes[index].name;
                eventTypes[index].name = newName;

                eventTypes.forEach(et => {
                    if (et.complementary === oldName) {
                        et.complementary = newName;
                    }
                });

                saveEventTypesToStorage(eventTypes);
                renderGlobalEventTypes();
            }
        }

        function updateGlobalEventTypeColor(index, newColor) {
            const eventTypes = getEventTypes();
            if (eventTypes[index]) {
                eventTypes[index].color = newColor;
                saveEventTypesToStorage(eventTypes);
            }
        }

        function updateGlobalEventTypeComplementary(index, complementaryName) {
            const eventTypes = getEventTypes();
            if (eventTypes[index]) {
                eventTypes[index].complementary = complementaryName || null;

                if (complementaryName) {
                    const complementaryIndex = eventTypes.findIndex(e => e.name === complementaryName);
                    if (complementaryIndex !== -1) {
                        eventTypes[complementaryIndex].complementary = eventTypes[index].name;
                    }
                }

                saveEventTypesToStorage(eventTypes);
                renderGlobalEventTypes();
            }
        }

        function deleteGlobalEventType(index) {
            const eventTypes = getEventTypes();
            const eventType = eventTypes[index];

            if (confirm(`Delete "${eventType.name}"? This cannot be undone.`)) {
                eventTypes.forEach(et => {
                    if (et.complementary === eventType.name) {
                        et.complementary = null;
                    }
                });

                eventTypes.splice(index, 1);
                saveEventTypesToStorage(eventTypes);
                renderGlobalEventTypes();
            }
        }

        function saveGlobalTimeScale() {
            const timeScale = parseInt(document.getElementById('globalTimeScaleSetting').value);
            const settings = getGlobalSettings();
            settings.timeScale = timeScale;
            saveGlobalSettings(settings);
            showToast('Time scale updated!');
        }

        function loadGlobalSettings() {
            const settings = getGlobalSettings();
            document.getElementById('globalTimeScaleSetting').value = settings.timeScale || 1;
        }

        function getComplementaryEvent(eventTypeName) {
            const eventTypes = getEventTypes();
            const eventType = eventTypes.find(e => e.name === eventTypeName);
            return eventType?.complementary || null;
        }

        function toggleEvent(eventType) {
            let activeEvents = getActiveEvents();
            const activeEvent = activeEvents.find(e => e.type === eventType);

            if (activeEvent) {
                stopEvent(activeEvent.id);
            } else {
                startEvent(eventType);
            }
        }

        function startEvent(eventType) {
            let activeEvents = getActiveEvents();

            const complementaryEventName = getComplementaryEvent(eventType);
            if (complementaryEventName) {
                const complementaryActiveEvents = activeEvents.filter(e => e.type === complementaryEventName);
                complementaryActiveEvents.forEach(e => {
                    stopEvent(e.id, true);
                });
                activeEvents = getActiveEvents();
            }

            const event = {
                id: Date.now() + Math.random(),
                type: eventType,
                startTime: new Date().toISOString(),
                endTime: null
            };

            activeEvents.push(event);
            saveActiveEvents(activeEvents);

            renderEventButtons();
            const complementaryMsg = complementaryEventName ? ` (stopped ${complementaryEventName})` : '';
            showToast(`${eventType} started!${complementaryMsg}`);
            startUpdateInterval();
        }

        function stopEvent(eventId, silent = false) {
            let activeEvents = getActiveEvents();
            const eventIndex = activeEvents.findIndex(e => e.id === eventId);

            if (eventIndex !== -1) {
                const event = activeEvents[eventIndex];
                event.endTime = new Date().toISOString();

                const startTime = new Date(event.startTime);
                const endTime = new Date(event.endTime);
                event.duration = Math.floor((endTime - startTime) / 1000);

                let events = getEvents();
                events.push(event);
                saveEvents(events);

                activeEvents.splice(eventIndex, 1);
                saveActiveEvents(activeEvents);

                if (!silent) {
                    renderEventButtons();
                    displayEvents();
                    showToast(`${event.type} stopped! Duration: ${formatDuration(event.duration)}`);
                }

                if (activeEvents.length === 0) {
                    stopUpdateInterval();
                }
            }
        }

        function getEvents() {
            if (!currentSessionId) return [];
            const stored = localStorage.getItem(getSessionStorageKey('events'));
            return stored ? JSON.parse(stored) : [];
        }

        function saveEvents(events) {
            if (!currentSessionId) return;
            localStorage.setItem(getSessionStorageKey('events'), JSON.stringify(events));
            updateSessionTimestamp(currentSessionId);
        }

        function getActiveEvents() {
            if (!currentSessionId) return [];
            const stored = localStorage.getItem(getSessionStorageKey('activeEvents'));
            return stored ? JSON.parse(stored) : [];
        }

        function saveActiveEvents(activeEvents) {
            if (!currentSessionId) return;
            localStorage.setItem(getSessionStorageKey('activeEvents'), JSON.stringify(activeEvents));
            updateSessionTimestamp(currentSessionId);
        }

        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;

            if (hours > 0) {
                return `${hours}h ${minutes}m ${secs}s`;
            } else if (minutes > 0) {
                return `${minutes}m ${secs}s`;
            } else {
                return `${secs}s`;
            }
        }

        function calculateDuration(startTime) {
            const start = new Date(startTime);
            const now = new Date();
            return Math.floor((now - start) / 1000);
        }

        function getEventTypes() {
            const settings = getGlobalSettings();
            return settings.eventTypes || DEFAULT_EVENT_TYPES;
        }

        function saveEventTypesToStorage(eventTypes) {
            const settings = getGlobalSettings();
            settings.eventTypes = eventTypes;
            saveGlobalSettings(settings);
        }

        function getSettings() {
            const globalSettings = getGlobalSettings();
            if (!currentSessionId) {
                return {
                    timeScale: globalSettings.timeScale || 1,
                    timelineDate: new Date().toISOString().split('T')[0],
                    timelineView: 'day',
                    timelineEndDate: new Date().toISOString().split('T')[0]
                };
            }
            const stored = localStorage.getItem(getSessionStorageKey('settings'));
            const sessionSettings = stored ? JSON.parse(stored) : {
                timelineDate: new Date().toISOString().split('T')[0],
                timelineView: 'day',
                timelineEndDate: new Date().toISOString().split('T')[0]
            };
            return {
                timeScale: globalSettings.timeScale || 1,
                ...sessionSettings
            };
        }

        function saveTimelineSettings() {
            if (!currentSessionId) return;
            const settings = getSettings();
            settings.timelineDate = document.getElementById('timelineDate').value;
            settings.timelineView = document.getElementById('timelineView').value;
            settings.timelineEndDate = document.getElementById('timelineEndDate').value;
            const sessionSettings = {
                timelineDate: settings.timelineDate,
                timelineView: settings.timelineView,
                timelineEndDate: settings.timelineEndDate
            };
            localStorage.setItem(getSessionStorageKey('settings'), JSON.stringify(sessionSettings));
        }

        function loadTimelineSettings() {
            const settings = getSettings();
            document.getElementById('timelineDate').value = settings.timelineDate;
            document.getElementById('timelineView').value = settings.timelineView;
            document.getElementById('timelineEndDate').value = settings.timelineEndDate;

            if (settings.timelineView === 'range') {
                document.getElementById('timelineEndDate').style.display = 'inline-block';
            } else {
                document.getElementById('timelineEndDate').style.display = 'none';
            }
        }

        function switchTab(tabName) {
            const tabs = document.querySelectorAll('.tab');
            const tabContents = document.querySelectorAll('.tab-content');

            tabs.forEach(tab => tab.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');

            if (tabName === 'timeline') {
                loadTimelineSettings();
                generateTimeline();
            }
        }



        function getEventTypeClass(name) {
            return name.toLowerCase().replace(/\s+/g, '-');
        }

        function renderEventButtons() {
            const activeEvents = getActiveEvents();
            const eventTypes = getEventTypes();
            const container = document.getElementById('eventButtons');

            if (!currentSessionId) {
                container.innerHTML = '<div class="empty-state">No session selected.</div>';
                return;
            }

            if (eventTypes.length === 0) {
                container.innerHTML = '<div class="empty-state">No event types defined. Return to the landing page to add event types in Global Settings.</div>';
                return;
            }

            updateDynamicStyles(eventTypes);

            container.innerHTML = eventTypes.map(eventType => {
                const activeInstances = activeEvents.filter(e => e.type === eventType.name);
                const isActive = activeInstances.length > 0;
                const instanceCount = activeInstances.length;
                const eventClass = getEventTypeClass(eventType.name);

                let durationDisplay = '';
                let statusDisplay = 'Click to Start';
                let icon = '‚ñ∂Ô∏è';

                if (isActive) {
                    const oldestEvent = activeInstances[0];
                    const duration = calculateDuration(oldestEvent.startTime);
                    durationDisplay = `<div class="event-btn-duration" id="btn-duration-${eventClass}">${formatDuration(duration)}</div>`;
                    statusDisplay = 'Running';
                    icon = '‚èπÔ∏è';
                }

                const instanceBadge = instanceCount > 1 ? `<div class="event-btn-instances">${instanceCount}</div>` : '';

                return `
                    <button class="event-btn ${eventClass} ${isActive ? 'active' : ''}"
                            onclick="toggleEvent('${eventType.name}')">
                        ${instanceBadge}
                        <div class="event-btn-label">${icon} ${eventType.name}</div>
                        <div class="event-btn-status">${statusDisplay}</div>
                        ${durationDisplay}
                    </button>
                `;
            }).join('');
        }

        function updateDynamicStyles(eventTypes) {
            let styleElement = document.getElementById('dynamic-event-styles');
            if (!styleElement) {
                styleElement = document.createElement('style');
                styleElement.id = 'dynamic-event-styles';
                document.head.appendChild(styleElement);
            }

            const styles = eventTypes.map(eventType => {
                const eventClass = getEventTypeClass(eventType.name);
                return `.event-btn.${eventClass} { background: ${eventType.color}; }`;
            }).join('\n');

            styleElement.textContent = styles;
        }

        function displayEvents() {
            const listContainer = document.getElementById('eventsList');

            if (!currentSessionId) {
                listContainer.innerHTML = '<div class="empty-state">No session selected.</div>';
                return;
            }

            const events = getEvents();
            const activeEvents = getActiveEvents();

            const allEvents = [...events];

            activeEvents.forEach(active => {
                allEvents.push({
                    ...active,
                    isActive: true
                });
            });

            if (allEvents.length === 0) {
                listContainer.innerHTML = '<div class="empty-state">No events yet. Start tracking above!</div>';
                return;
            }

            const sortedEvents = allEvents.sort((a, b) => {
                const timeA = new Date(a.startTime || a.timestamp);
                const timeB = new Date(b.startTime || b.timestamp);
                return timeB - timeA;
            });

            const eventColors = getEventColors();
            listContainer.innerHTML = sortedEvents.map(event => {
                const color = eventColors[event.type] || '#999';
                let timeInfo, durationInfo = '';

                if (event.isActive) {
                    const startTime = new Date(event.startTime).toLocaleString();
                    timeInfo = `${startTime} - RUNNING`;
                    const duration = calculateDuration(event.startTime);
                    durationInfo = `<span class="event-duration">(${formatDuration(duration)})</span>`;
                } else if (event.endTime) {
                    const startTime = new Date(event.startTime).toLocaleString();
                    const endTime = new Date(event.endTime).toLocaleString();
                    timeInfo = `${startTime} - ${endTime}`;
                    durationInfo = `<span class="event-duration">(${formatDuration(event.duration)})</span>`;
                } else {
                    timeInfo = event.displayTime || new Date(event.timestamp).toLocaleString();
                }

                return `
                    <div class="event-item ${event.isActive ? 'running' : ''}" style="border-left-color: ${color}">
                        <span class="event-type">${event.type}</span>
                        <span class="event-time">${timeInfo} ${durationInfo}</span>
                    </div>
                `;
            }).join('');
        }

        function startUpdateInterval() {
            if (updateInterval) return;

            updateInterval = setInterval(() => {
                const activeEvents = getActiveEvents();
                if (activeEvents.length === 0) {
                    stopUpdateInterval();
                    return;
                }

                const eventTypes = getEventTypes();
                eventTypes.forEach(eventType => {
                    const activeInstances = activeEvents.filter(e => e.type === eventType.name);
                    if (activeInstances.length > 0) {
                        const oldestEvent = activeInstances[0];
                        const duration = calculateDuration(oldestEvent.startTime);
                        const eventClass = getEventTypeClass(eventType.name);
                        const durationElement = document.getElementById(`btn-duration-${eventClass}`);
                        if (durationElement) {
                            durationElement.textContent = formatDuration(duration);
                        }
                    }
                });

                displayEvents();
            }, 1000);
        }

        function stopUpdateInterval() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
        }

        function exportCSV() {
            const events = getEvents();
            const activeEvents = getActiveEvents();

            if (events.length === 0 && activeEvents.length === 0) {
                showToast('No events to export!');
                return;
            }

            const allEvents = [...events];
            activeEvents.forEach(active => {
                allEvents.push({
                    ...active,
                    endTime: new Date().toISOString(),
                    duration: calculateDuration(active.startTime),
                    isActive: true
                });
            });

            const sortedEvents = allEvents.sort((a, b) => {
                const timeA = new Date(a.startTime || a.timestamp);
                const timeB = new Date(b.startTime || b.timestamp);
                return timeA - timeB;
            });

            let csvContent = 'Event Type,Start Time,End Time,Duration (seconds),Status\n';

            sortedEvents.forEach(event => {
                const escapedType = `"${event.type.replace(/"/g, '""')}"`;
                const startTime = event.startTime || event.timestamp;
                const endTime = event.endTime || '';
                const duration = event.duration || 0;
                const status = event.isActive ? 'RUNNING' : 'COMPLETED';
                csvContent += `${escapedType},${startTime},${endTime},${duration},${status}\n`;
            });

            const dataBlob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `events_${new Date().toISOString().split('T')[0]}.csv`;
            link.click();
            URL.revokeObjectURL(url);

            showToast('Events exported to CSV!');
        }

        function resetEvents() {
            if (!currentSessionId) return;
            if (confirm('Are you sure you want to reset all events in this session? This will stop all active events and clear all data. This cannot be undone.')) {
                localStorage.removeItem(getSessionStorageKey('events'));
                localStorage.removeItem(getSessionStorageKey('activeEvents'));
                localStorage.removeItem(getSessionStorageKey('settings'));
                stopUpdateInterval();
                renderEventButtons();
                displayEvents();
                clearTimeline();
                updateSessionTimestamp(currentSessionId);
                showToast('All events have been reset!');
            }
        }

        function clearTimeline() {
            const canvas = document.getElementById('timelineCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const legend = document.getElementById('timelineLegend');
            legend.innerHTML = '';
        }

        function showToast(message) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        function getEventColors() {
            const eventTypes = getEventTypes();
            const colors = {};
            eventTypes.forEach(eventType => {
                colors[eventType.name] = eventType.color;
            });
            return colors;
        }

        function toggleTimeline() {
            switchTab('timeline');
        }

        function generateTimeline() {
            const events = getEvents();
            const activeEvents = getActiveEvents();

            const allEvents = [...events];
            activeEvents.forEach(active => {
                allEvents.push({
                    ...active,
                    endTime: new Date().toISOString(),
                    duration: calculateDuration(active.startTime),
                    isActive: true
                });
            });

            if (allEvents.length === 0) {
                showToast('No events to display in timeline!');
                return;
            }

            const viewType = document.getElementById('timelineView').value;
            const dateInput = document.getElementById('timelineDate');
            const endDateInput = document.getElementById('timelineEndDate');

            if (viewType === 'range') {
                endDateInput.style.display = 'inline-block';
                if (!endDateInput.value) {
                    endDateInput.value = new Date().toISOString().split('T')[0];
                }
            } else {
                endDateInput.style.display = 'none';
            }

            const canvas = document.getElementById('timelineCanvas');
            const ctx = canvas.getContext('2d');

            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = 650 * dpr;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = '650px';
            ctx.scale(dpr, dpr);

            const width = rect.width;
            const height = 650;
            const headerHeight = 50;
            const leftPadding = 150;
            const rightPadding = 60;
            const topBottomPadding = 60;
            const chartHeight = height - topBottomPadding * 2 - headerHeight;

            ctx.clearRect(0, 0, width, height);

            let filteredEvents;
            let startTime, endTime;

            if (viewType === 'day') {
                const selectedDate = new Date(dateInput.value);
                const dayStart = new Date(selectedDate.setHours(0, 0, 0, 0));
                const dayEnd = new Date(selectedDate.setHours(23, 59, 59, 999));

                filteredEvents = allEvents.filter(e => {
                    const eventTime = new Date(e.startTime || e.timestamp);
                    return eventTime >= dayStart && eventTime <= dayEnd;
                });
            } else {
                const startDate = new Date(dateInput.value);
                const endDate = new Date(endDateInput.value);
                const rangeStart = new Date(startDate.setHours(0, 0, 0, 0));
                const rangeEnd = new Date(endDate.setHours(23, 59, 59, 999));

                filteredEvents = allEvents.filter(e => {
                    const eventTime = new Date(e.startTime || e.timestamp);
                    return eventTime >= rangeStart && eventTime <= rangeEnd;
                });
            }

            if (filteredEvents.length === 0) {
                ctx.fillStyle = '#999';
                ctx.font = '16px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No events found for selected date/range', width / 2, height / 2);
                return;
            }

            filteredEvents.sort((a, b) => {
                const timeA = new Date(a.startTime || a.timestamp);
                const timeB = new Date(b.startTime || b.timestamp);
                return timeA - timeB;
            });

            const eventTimes = [];
            filteredEvents.forEach(e => {
                eventTimes.push(new Date(e.startTime || e.timestamp).getTime());
                if (e.endTime) {
                    eventTimes.push(new Date(e.endTime).getTime());
                }
            });

            const minEventTime = Math.min(...eventTimes);
            const maxEventTime = Math.max(...eventTimes);

            const settings = getSettings();
            const timeScale = settings.timeScale;
            const buffer = (maxEventTime - minEventTime) * 0.1;

            startTime = new Date(minEventTime - buffer);
            endTime = new Date(maxEventTime + buffer);

            drawTimeline(ctx, filteredEvents, startTime, endTime, width, height, leftPadding, rightPadding, topBottomPadding, chartHeight, viewType, headerHeight);
            updateLegend();
        }

        let timelineEventRects = [];

        function drawTimeline(ctx, events, startTime, endTime, width, height, leftPadding, rightPadding, topBottomPadding, chartHeight, viewType, headerHeight) {
            timelineEventRects = [];
            const settings = getSettings();
            const timeScale = settings.timeScale;
            const actualTimeRange = endTime - startTime;
            const scaledTimeRange = actualTimeRange / timeScale;
            const chartWidth = width - leftPadding - rightPadding;

            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, width, headerHeight);

            ctx.fillStyle = '#333';
            ctx.font = 'bold 18px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Activity Timeline', width / 2, 25);

            const minTime = new Date(Math.min(...events.map(e => new Date(e.timestamp))));
            const maxTime = new Date(Math.max(...events.map(e => new Date(e.timestamp))));
            const timeRangeText = `${minTime.toLocaleString()} - ${maxTime.toLocaleString()}`;

            ctx.fillStyle = '#666';
            ctx.font = '13px sans-serif';
            ctx.fillText(timeRangeText, width / 2, 43);

            const chartTop = headerHeight + topBottomPadding;
            ctx.fillStyle = '#f3f4f6';
            ctx.fillRect(leftPadding, chartTop, chartWidth, chartHeight);

            ctx.strokeStyle = '#d1d5db';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(leftPadding, chartTop);
            ctx.lineTo(leftPadding, chartTop + chartHeight);
            ctx.lineTo(leftPadding + chartWidth, chartTop + chartHeight);
            ctx.stroke();

            const scaledRangeMs = scaledTimeRange * 1000;
            let numTicks, tickInterval;

            if (scaledRangeMs < 60000) {
                numTicks = 10;
                tickInterval = scaledRangeMs / numTicks;
            } else if (scaledRangeMs < 3600000) {
                numTicks = Math.min(12, Math.ceil(scaledRangeMs / 60000));
                tickInterval = scaledRangeMs / numTicks;
            } else if (scaledRangeMs < 86400000) {
                numTicks = Math.min(24, Math.ceil(scaledRangeMs / 3600000));
                tickInterval = scaledRangeMs / numTicks;
            } else {
                numTicks = Math.min(10, Math.ceil(scaledRangeMs / 86400000));
                tickInterval = scaledRangeMs / numTicks;
            }

            for (let i = 0; i <= numTicks; i++) {
                const x = leftPadding + (chartWidth * i / numTicks);
                const actualTickTime = startTime.getTime() + (actualTimeRange * i / numTicks);
                const tickTime = new Date(actualTickTime);

                ctx.strokeStyle = '#e5e7eb';
                ctx.beginPath();
                ctx.moveTo(x, chartTop);
                ctx.lineTo(x, chartTop + chartHeight);
                ctx.stroke();

                ctx.fillStyle = '#666';
                ctx.font = '11px sans-serif';
                ctx.textAlign = 'center';

                let label;
                if (scaledRangeMs < 60000) {
                    label = tickTime.getSeconds() + 's';
                } else if (scaledRangeMs < 3600000) {
                    label = tickTime.getHours() + ':' + String(tickTime.getMinutes()).padStart(2, '0');
                } else if (scaledRangeMs < 86400000) {
                    label = tickTime.getHours() + ':' + String(tickTime.getMinutes()).padStart(2, '0');
                } else {
                    label = (tickTime.getMonth() + 1) + '/' + tickTime.getDate() + ' ' + tickTime.getHours() + ':' + String(tickTime.getMinutes()).padStart(2, '0');
                }

                ctx.fillText(label, x, chartTop + chartHeight + 20);
            }

            const rowHeight = 40;
            const eventTypes = [...new Set(events.map(e => e.type))];
            const totalRows = eventTypes.length;
            const actualRowHeight = Math.min(rowHeight, chartHeight / totalRows);

            eventTypes.forEach((type, index) => {
                const y = chartTop + (index * actualRowHeight);

                ctx.fillStyle = '#fff';
                ctx.fillRect(0, y, leftPadding - 5, actualRowHeight - 2);

                ctx.fillStyle = '#333';
                ctx.font = 'bold 13px sans-serif';
                ctx.textAlign = 'right';
                ctx.fillText(type, leftPadding - 10, y + actualRowHeight / 2 + 5);
            });

            events.forEach(event => {
                const eventStartTime = new Date(event.startTime || event.timestamp);
                const eventEndTime = event.endTime ? new Date(event.endTime) : eventStartTime;

                const scaledStartTime = (eventStartTime - startTime) / timeScale;
                const scaledEndTime = (eventEndTime - startTime) / timeScale;

                const x1 = leftPadding + (scaledStartTime / scaledTimeRange) * chartWidth;
                const x2 = leftPadding + (scaledEndTime / scaledTimeRange) * chartWidth;

                const typeIndex = eventTypes.indexOf(event.type);
                const y = chartTop + (typeIndex * actualRowHeight);
                const barHeight = actualRowHeight - 10;

                const eventColors = getEventColors();
                const color = eventColors[event.type] || '#999';

                if (event.endTime && event.startTime !== event.endTime) {
                    const rectX = x1;
                    const rectY = y + 5;
                    const rectWidth = Math.max(x2 - x1, 2);
                    const rectHeight = barHeight;

                    ctx.fillStyle = color;
                    ctx.globalAlpha = event.isActive ? 0.7 : 0.5;
                    ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
                    ctx.globalAlpha = 1;

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);

                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x1, y + actualRowHeight / 2, 5, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.beginPath();
                    ctx.arc(x2, y + actualRowHeight / 2, 5, 0, Math.PI * 2);
                    ctx.fill();

                    timelineEventRects.push({
                        x: rectX,
                        y: rectY,
                        width: rectWidth,
                        height: rectHeight,
                        event: event
                    });
                } else {
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x1, y + actualRowHeight / 2, 6, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    timelineEventRects.push({
                        x: x1 - 6,
                        y: y + actualRowHeight / 2 - 6,
                        width: 12,
                        height: 12,
                        event: event
                    });
                }
            });
        }

        function updateLegend() {
            const legend = document.getElementById('timelineLegend');
            const eventColors = getEventColors();
            legend.innerHTML = Object.entries(eventColors).map(([type, color]) => `
                <div class="legend-item">
                    <div class="legend-color" style="background: ${color}"></div>
                    <span class="legend-label">${type}</span>
                </div>
            `).join('');
        }

        function downloadTimeline() {
            const canvas = document.getElementById('timelineCanvas');
            const link = document.createElement('a');
            const dateStr = document.getElementById('timelineDate').value;
            link.download = `timeline_${dateStr}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            showToast('Timeline downloaded!');
        }

        document.getElementById('timelineView').addEventListener('change', function() {
            if (this.value === 'range') {
                document.getElementById('timelineEndDate').style.display = 'inline-block';
            } else {
                document.getElementById('timelineEndDate').style.display = 'none';
            }
        });

        const canvas = document.getElementById('timelineCanvas');
        const tooltip = document.getElementById('timelineTooltip');

        canvas.addEventListener('mousemove', function(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            let found = false;
            for (const eventRect of timelineEventRects) {
                if (x >= eventRect.x && x <= eventRect.x + eventRect.width &&
                    y >= eventRect.y && y <= eventRect.y + eventRect.height) {

                    const event = eventRect.event;
                    const startTime = new Date(event.startTime || event.timestamp);
                    const endTime = event.endTime ? new Date(event.endTime) : null;

                    let tooltipText = `<strong>${event.type}</strong><br>`;
                    tooltipText += `Start: ${startTime.toLocaleString()}<br>`;
                    if (endTime) {
                        tooltipText += `End: ${endTime.toLocaleString()}<br>`;
                        tooltipText += `Duration: ${formatDuration(event.duration)}`;
                    }

                    tooltip.innerHTML = tooltipText;
                    tooltip.style.display = 'block';
                    tooltip.style.left = (e.pageX + 15) + 'px';
                    tooltip.style.top = (e.pageY + 15) + 'px';

                    found = true;
                    break;
                }
            }

            if (!found) {
                tooltip.style.display = 'none';
            }
        });

        canvas.addEventListener('mouseleave', function() {
            tooltip.style.display = 'none';
        });

        showLandingView();
    </script>
</body>
</html>
